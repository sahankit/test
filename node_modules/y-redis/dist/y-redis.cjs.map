{"version":3,"file":"y-redis.cjs","sources":["../src/y-redis.js"],"sourcesContent":["import * as Y from 'yjs'\nimport * as mutex from 'lib0/mutex'\nimport { Observable } from 'lib0/observable'\nimport * as promise from 'lib0/promise'\nimport * as error from 'lib0/error'\nimport * as logging from 'lib0/logging'\nimport Redis from 'ioredis'\n\nconst logger = logging.createModuleLogger('y-redis')\n\n/**\n * Handles persistence of a sinle doc.\n */\nexport class PersistenceDoc {\n  /**\n   * @param {RedisPersistence} rp\n   * @param {string} name\n   * @param {Y.Doc} doc\n   */\n  constructor (rp, name, doc) {\n    this.rp = rp\n    this.name = name\n    this.doc = doc\n    this.mux = mutex.createMutex()\n    /**\n     * Next expected index / len of the list of updates\n     * @type {number}\n     */\n    this._clock = 0\n    this._fetchingClock = 0\n    /**\n     * @param {Uint8Array} update\n     */\n    this.updateHandler = update => {\n      // mux: only store update in redis if this document update does not originate from redis\n      this.mux(() => {\n        rp.redis.rpushBuffer(name + ':updates', Buffer.from(update)).then(len => {\n          if (len === this._clock + 1) {\n            this._clock++\n            if (this._fetchingClock < this._clock) {\n              this._fetchingClock = this._clock\n            }\n          }\n          // @ts-ignore\n          rp.redis.publish(this.name, len.toString())\n        })\n      })\n    }\n    if (doc.store.clients.size > 0) {\n      this.updateHandler(Y.encodeStateAsUpdate(doc))\n    }\n    doc.on('update', this.updateHandler)\n    this.synced = rp.sub.subscribe(name).then(() => this.getUpdates())\n  }\n\n  /**\n   * @return {Promise<any>}\n   */\n  destroy () {\n    this.doc.off('update', this.updateHandler)\n    this.rp.docs.delete(this.name)\n    return this.rp.sub.unsubscribe(this.name)\n  }\n\n  /**\n   * Get all new updates from redis and increase clock if necessary.\n   *\n   * @return {Promise<PersistenceDoc>}\n   */\n  getUpdates () {\n    const startClock = this._clock\n    return this.rp.redis.lrangeBuffer(this.name + ':updates', startClock, -1).then(/** @type {function(Array<Buffer>)} */ updates => {\n      logger('Fetched ', logging.BOLD, logging.PURPLE, (updates.length).toString().padEnd(2), logging.UNBOLD, logging.UNCOLOR, ' updates')\n      this.mux(() => {\n        this.doc.transact(() => {\n          updates.forEach(update => {\n            Y.applyUpdate(this.doc, update)\n          })\n          const nextClock = startClock + updates.length\n          if (this._clock < nextClock) {\n            this._clock = nextClock\n          }\n          if (this._fetchingClock < this._clock) {\n            this._fetchingClock = this._clock\n          }\n        })\n      })\n      if (this._fetchingClock <= this._clock) {\n        return this\n      } else {\n        // there is still something missing. new updates came in. fetch again.\n        if (updates.length === 0) {\n          // Calling getUpdates recursively has the potential to be an infinite fetch-call.\n          // In case no new updates came in, reset _fetching clock (in case the pubsub lied / send an invalid message).\n          // Being overly protective here..\n          this._fetchingClock = this._clock\n        }\n        return this.getUpdates()\n      }\n    })\n  }\n}\n\n/**\n * @param {Object|null} redisOpts\n * @param {Array<Object>|null} redisClusterOpts\n * @return {Redis.Redis | Redis.Cluster}\n */\nconst createRedisInstance = (redisOpts, redisClusterOpts) => redisClusterOpts\n  ? new Redis.Cluster(redisClusterOpts)\n  : (redisOpts ? new Redis(redisOpts) : new Redis())\n\n/**\n * @extends Observable<string>\n */\nexport class RedisPersistence extends Observable {\n  /**\n   * @param {Object} [opts]\n   * @param {Object|null} [opts.redisOpts]\n   * @param {Array<Object>|null} [opts.redisClusterOpts]\n   */\n  constructor ({ redisOpts = /** @type {any} */ (null), redisClusterOpts = /** @type {any} */ (null) } = {}) {\n    super()\n    this.redis = createRedisInstance(redisOpts, redisClusterOpts)\n    this.sub = /** @type {Redis.Redis} */ (createRedisInstance(redisOpts, redisClusterOpts))\n    /**\n     * @type {Map<string,PersistenceDoc>}\n     */\n    this.docs = new Map()\n    this.sub.on('message', (channel, sclock) => {\n      // console.log('message', channel, sclock)\n      const pdoc = this.docs.get(channel)\n      if (pdoc) {\n        const clock = Number(sclock) || Number.POSITIVE_INFINITY // case of null\n        if (pdoc._fetchingClock < clock) {\n          // do not query doc updates if this document is currently already fetching\n          const isCurrentlyFetching = pdoc._fetchingClock !== pdoc._clock\n          if (pdoc._fetchingClock < clock) {\n            pdoc._fetchingClock = clock\n          }\n          if (!isCurrentlyFetching) {\n            pdoc.getUpdates()\n          }\n        }\n      } else {\n        this.sub.unsubscribe(channel)\n      }\n    })\n  }\n\n  /**\n   * @param {string} name\n   * @param {Y.Doc} ydoc\n   * @return {PersistenceDoc}\n   */\n  bindState (name, ydoc) {\n    if (this.docs.has(name)) {\n      throw error.create(`\"${name}\" is already bound to this RedisPersistence instance`)\n    }\n    const pd = new PersistenceDoc(this, name, ydoc)\n    this.docs.set(name, pd)\n    return pd\n  }\n\n  destroy () {\n    const docs = this.docs\n    this.docs = new Map()\n    return promise.all(Array.from(docs.values()).map(doc => doc.destroy())).then(() => {\n      this.redis.quit()\n      this.sub.quit()\n      // @ts-ignore\n      this.redis = null\n      // @ts-ignore\n      this.sub = null\n    })\n  }\n\n  /**\n   * @param {string} name\n   */\n  closeDoc (name) {\n    const doc = this.docs.get(name)\n    if (doc) {\n      return doc.destroy()\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @return {Promise<any>}\n   */\n  clearDocument (name) {\n    const doc = this.docs.get(name)\n    if (doc) {\n      doc.destroy()\n    }\n    return this.redis.del(name + ':updates')\n  }\n\n  /**\n   * Destroys this instance and removes all known documents from the database.\n   * After that this Persistence instance is destroyed.\n   *\n   * @return {Promise<any>}\n   */\n  clearAllDocuments () {\n    return promise.all(Array.from(this.docs.keys()).map(name => this.redis.del(name + ':updates'))).then(() => {\n      this.destroy()\n    })\n  }\n}\n"],"names":["logging.createModuleLogger","mutex.createMutex","Y.encodeStateAsUpdate","logging.BOLD","logging.PURPLE","logging.UNBOLD","logging.UNCOLOR","Y.applyUpdate","Observable","error.create","promise.all"],"mappings":";;;;;;;;;;;;;;AAQA,MAAM,MAAM,GAAGA,0BAA0B,CAAC,SAAS,EAAC;AACpD;AACA;AACA;AACA;AACO,MAAM,cAAc,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE;AAC9B,IAAI,IAAI,CAAC,EAAE,GAAG,GAAE;AAChB,IAAI,IAAI,CAAC,IAAI,GAAG,KAAI;AACpB,IAAI,IAAI,CAAC,GAAG,GAAG,IAAG;AAClB,IAAI,IAAI,CAAC,GAAG,GAAGC,iBAAiB,GAAE;AAClC;AACA;AACA;AACA;AACA,IAAI,IAAI,CAAC,MAAM,GAAG,EAAC;AACnB,IAAI,IAAI,CAAC,cAAc,GAAG,EAAC;AAC3B;AACA;AACA;AACA,IAAI,IAAI,CAAC,aAAa,GAAG,MAAM,IAAI;AACnC;AACA,MAAM,IAAI,CAAC,GAAG,CAAC,MAAM;AACrB,QAAQ,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,GAAG,UAAU,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI;AACjF,UAAU,IAAI,GAAG,KAAK,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;AACvC,YAAY,IAAI,CAAC,MAAM,GAAE;AACzB,YAAY,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,MAAM,EAAE;AACnD,cAAc,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,OAAM;AAC/C,aAAa;AACb,WAAW;AACX;AACA,UAAU,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,QAAQ,EAAE,EAAC;AACrD,SAAS,EAAC;AACV,OAAO,EAAC;AACR,MAAK;AACL,IAAI,IAAI,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,EAAE;AACpC,MAAM,IAAI,CAAC,aAAa,CAACC,qBAAqB,CAAC,GAAG,CAAC,EAAC;AACpD,KAAK;AACL,IAAI,GAAG,CAAC,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,EAAC;AACxC,IAAI,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,UAAU,EAAE,EAAC;AACtE,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,EAAC;AAC9C,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAC;AAClC,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC;AAC7C,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,UAAU,CAAC,GAAG;AAChB,IAAI,MAAM,UAAU,GAAG,IAAI,CAAC,OAAM;AAClC,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,GAAG,UAAU,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,wCAAwC,OAAO,IAAI;AACrI,MAAM,MAAM,CAAC,UAAU,EAAEC,YAAY,EAAEC,cAAc,EAAE,CAAC,OAAO,CAAC,MAAM,EAAE,QAAQ,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAEC,cAAc,EAAEC,eAAe,EAAE,UAAU,EAAC;AAC1I,MAAM,IAAI,CAAC,GAAG,CAAC,MAAM;AACrB,QAAQ,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM;AAChC,UAAU,OAAO,CAAC,OAAO,CAAC,MAAM,IAAI;AACpC,YAAYC,aAAa,CAAC,IAAI,CAAC,GAAG,EAAE,MAAM,EAAC;AAC3C,WAAW,EAAC;AACZ,UAAU,MAAM,SAAS,GAAG,UAAU,GAAG,OAAO,CAAC,OAAM;AACvD,UAAU,IAAI,IAAI,CAAC,MAAM,GAAG,SAAS,EAAE;AACvC,YAAY,IAAI,CAAC,MAAM,GAAG,UAAS;AACnC,WAAW;AACX,UAAU,IAAI,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,MAAM,EAAE;AACjD,YAAY,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,OAAM;AAC7C,WAAW;AACX,SAAS,EAAC;AACV,OAAO,EAAC;AACR,MAAM,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,MAAM,EAAE;AAC9C,QAAQ,OAAO,IAAI;AACnB,OAAO,MAAM;AACb;AACA,QAAQ,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AAClC;AACA;AACA;AACA,UAAU,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,OAAM;AAC3C,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC,UAAU,EAAE;AAChC,OAAO;AACP,KAAK,CAAC;AACN,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mBAAmB,GAAG,CAAC,SAAS,EAAE,gBAAgB,KAAK,gBAAgB;AAC7E,IAAI,IAAI,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC;AACvC,KAAK,SAAS,GAAG,IAAI,KAAK,CAAC,SAAS,CAAC,GAAG,IAAI,KAAK,EAAE,EAAC;AACpD;AACA;AACA;AACA;AACO,MAAM,gBAAgB,SAASC,qBAAU,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA,EAAE,WAAW,CAAC,CAAC,EAAE,SAAS,uBAAuB,IAAI,CAAC,EAAE,gBAAgB,uBAAuB,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE;AAC7G,IAAI,KAAK,GAAE;AACX,IAAI,IAAI,CAAC,KAAK,GAAG,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,EAAC;AACjE,IAAI,IAAI,CAAC,GAAG,+BAA+B,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,EAAC;AAC5F;AACA;AACA;AACA,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG,GAAE;AACzB,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,OAAO,EAAE,MAAM,KAAK;AAChD;AACA,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,EAAC;AACzC,MAAM,IAAI,IAAI,EAAE;AAChB,QAAQ,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,kBAAiB;AAChE,QAAQ,IAAI,IAAI,CAAC,cAAc,GAAG,KAAK,EAAE;AACzC;AACA,UAAU,MAAM,mBAAmB,GAAG,IAAI,CAAC,cAAc,KAAK,IAAI,CAAC,OAAM;AACzE,UAAU,IAAI,IAAI,CAAC,cAAc,GAAG,KAAK,EAAE;AAC3C,YAAY,IAAI,CAAC,cAAc,GAAG,MAAK;AACvC,WAAW;AACX,UAAU,IAAI,CAAC,mBAAmB,EAAE;AACpC,YAAY,IAAI,CAAC,UAAU,GAAE;AAC7B,WAAW;AACX,SAAS;AACT,OAAO,MAAM;AACb,QAAQ,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,EAAC;AACrC,OAAO;AACP,KAAK,EAAC;AACN,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE;AACzB,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AAC7B,MAAM,MAAMC,YAAY,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,oDAAoD,CAAC,CAAC;AACxF,KAAK;AACL,IAAI,MAAM,EAAE,GAAG,IAAI,cAAc,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAC;AACnD,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,EAAC;AAC3B,IAAI,OAAO,EAAE;AACb,GAAG;AACH;AACA,EAAE,OAAO,CAAC,GAAG;AACb,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,KAAI;AAC1B,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG,GAAE;AACzB,IAAI,OAAOC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM;AACvF,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,GAAE;AACvB,MAAM,IAAI,CAAC,GAAG,CAAC,IAAI,GAAE;AACrB;AACA,MAAM,IAAI,CAAC,KAAK,GAAG,KAAI;AACvB;AACA,MAAM,IAAI,CAAC,GAAG,GAAG,KAAI;AACrB,KAAK,CAAC;AACN,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE,QAAQ,CAAC,CAAC,IAAI,EAAE;AAClB,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAC;AACnC,IAAI,IAAI,GAAG,EAAE;AACb,MAAM,OAAO,GAAG,CAAC,OAAO,EAAE;AAC1B,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE,aAAa,CAAC,CAAC,IAAI,EAAE;AACvB,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAC;AACnC,IAAI,IAAI,GAAG,EAAE;AACb,MAAM,GAAG,CAAC,OAAO,GAAE;AACnB,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,GAAG,UAAU,CAAC;AAC5C,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,iBAAiB,CAAC,GAAG;AACvB,IAAI,OAAOA,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM;AAC/G,MAAM,IAAI,CAAC,OAAO,GAAE;AACpB,KAAK,CAAC;AACN,GAAG;AACH;;;;;"}