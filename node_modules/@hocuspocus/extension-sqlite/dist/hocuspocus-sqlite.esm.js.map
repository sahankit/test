{"version":3,"file":"hocuspocus-sqlite.esm.js","sources":["../src/SQLite.ts"],"sourcesContent":["import { Database, DatabaseConfiguration } from '@hocuspocus/extension-database'\nimport sqlite3 from 'sqlite3'\nimport kleur from 'kleur'\n\nexport const schema = `CREATE TABLE IF NOT EXISTS \"documents\" (\n  \"name\" varchar(255) NOT NULL,\n  \"data\" blob NOT NULL,\n  UNIQUE(name)\n)`\n\nexport const selectQuery = `\n  SELECT data FROM \"documents\" WHERE name = $name ORDER BY rowid DESC\n`\n\nexport const upsertQuery = `\n  INSERT INTO \"documents\" (\"name\", \"data\") VALUES ($name, $data)\n    ON CONFLICT(name) DO UPDATE SET data = $data\n`\n\nconst SQLITE_INMEMORY = ':memory:'\n\nexport interface SQLiteConfiguration extends DatabaseConfiguration {\n  /**\n   * Valid values are filenames, \":memory:\" for an anonymous in-memory database and an empty\n   * string for an anonymous disk-based database. Anonymous databases are not persisted and\n   * when closing the database handle, their contents are lost.\n   *\n   * https://github.com/mapbox/node-sqlite3/wiki/API#new-sqlite3databasefilename-mode-callback\n   */\n  database: string,\n  /**\n   * The database schema to create.\n   */\n  schema: string,\n}\n\nexport class SQLite extends Database {\n  db?: sqlite3.Database\n\n  configuration: SQLiteConfiguration = {\n    database: SQLITE_INMEMORY,\n    schema,\n    fetch: async ({ documentName }) => {\n      return new Promise((resolve, reject) => {\n        this.db?.get(selectQuery, {\n          $name: documentName,\n        }, (error, row) => {\n          if (error) {\n            reject(error)\n          }\n\n          resolve((row as any)?.data)\n        })\n      })\n    },\n    store: async ({ documentName, state }) => {\n      this.db?.run(upsertQuery, {\n        $name: documentName,\n        $data: state,\n      })\n    },\n  }\n\n  constructor(configuration?: Partial<SQLiteConfiguration>) {\n    super({})\n\n    this.configuration = {\n      ...this.configuration,\n      ...configuration,\n    }\n  }\n\n  async onConfigure() {\n    this.db = new sqlite3.Database(this.configuration.database)\n    this.db.run(this.configuration.schema)\n  }\n\n  async onListen() {\n    if (this.configuration.database === SQLITE_INMEMORY) {\n      console.warn(`  ${kleur.yellow('The SQLite extension is configured as an in-memory database. All changes will be lost on restart!')}`)\n      console.log()\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAIa,MAAA,MAAM,GAAG,CAAA;;;;GAIpB;AAEW,MAAA,WAAW,GAAG,CAAA;;EAE1B;AAEY,MAAA,WAAW,GAAG,CAAA;;;EAG1B;AAED,MAAM,eAAe,GAAG,UAAU,CAAA;AAiB5B,MAAO,MAAO,SAAQ,QAAQ,CAAA;AA2BlC,IAAA,WAAA,CAAY,aAA4C,EAAA;QACtD,KAAK,CAAC,EAAE,CAAC,CAAA;AAzBX,QAAA,IAAA,CAAA,aAAa,GAAwB;AACnC,YAAA,QAAQ,EAAE,eAAe;YACzB,MAAM;AACN,YAAA,KAAK,EAAE,OAAO,EAAE,YAAY,EAAE,KAAI;gBAChC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAI;;AACrC,oBAAA,CAAA,EAAA,GAAA,IAAI,CAAC,EAAE,0CAAE,GAAG,CAAC,WAAW,EAAE;AACxB,wBAAA,KAAK,EAAE,YAAY;AACpB,qBAAA,EAAE,CAAC,KAAK,EAAE,GAAG,KAAI;AAChB,wBAAA,IAAI,KAAK,EAAE;4BACT,MAAM,CAAC,KAAK,CAAC,CAAA;AACd,yBAAA;wBAED,OAAO,CAAE,GAAW,KAAX,IAAA,IAAA,GAAG,uBAAH,GAAG,CAAU,IAAI,CAAC,CAAA;AAC7B,qBAAC,CAAC,CAAA;AACJ,iBAAC,CAAC,CAAA;aACH;YACD,KAAK,EAAE,OAAO,EAAE,YAAY,EAAE,KAAK,EAAE,KAAI;;AACvC,gBAAA,CAAA,EAAA,GAAA,IAAI,CAAC,EAAE,0CAAE,GAAG,CAAC,WAAW,EAAE;AACxB,oBAAA,KAAK,EAAE,YAAY;AACnB,oBAAA,KAAK,EAAE,KAAK;AACb,iBAAA,CAAC,CAAA;aACH;SACF,CAAA;QAKC,IAAI,CAAC,aAAa,GAAG;YACnB,GAAG,IAAI,CAAC,aAAa;AACrB,YAAA,GAAG,aAAa;SACjB,CAAA;KACF;AAED,IAAA,MAAM,WAAW,GAAA;AACf,QAAA,IAAI,CAAC,EAAE,GAAG,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAA;QAC3D,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAA;KACvC;AAED,IAAA,MAAM,QAAQ,GAAA;AACZ,QAAA,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,eAAe,EAAE;AACnD,YAAA,OAAO,CAAC,IAAI,CAAC,CAAA,EAAA,EAAK,KAAK,CAAC,MAAM,CAAC,mGAAmG,CAAC,CAAE,CAAA,CAAC,CAAA;YACtI,OAAO,CAAC,GAAG,EAAE,CAAA;AACd,SAAA;KACF;AACF;;;;"}